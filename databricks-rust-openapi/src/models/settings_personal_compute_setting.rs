use schemars::JsonSchema;
/*
 * Databricks Accounts and Workspace REST API on ALL
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(JsonSchema, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SettingsPersonalComputeSetting {
    /// etag used for versioning. The response is at least as fresh as the eTag provided. This is used for optimistic concurrency control as a way to help prevent simultaneous writes of a setting overwriting each other. It is strongly suggested that systems make use of the etag in the read -> update pattern to perform setting updates in order to avoid race conditions. That is, get an etag from a GET request, and pass it with the PATCH request to identify the setting version you are updating. 
    #[serde(rename = "etag", skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    #[serde(rename = "personal_compute")]
    pub personal_compute: Box<crate::models::SettingsPersonalComputeMessage>,
    /// Name of the corresponding setting. Needs to be 'default' if there is only one setting instance per account.
    #[serde(rename = "setting_name", skip_serializing_if = "Option::is_none")]
    pub setting_name: Option<String>,
}

impl SettingsPersonalComputeSetting {
    pub fn new(personal_compute: crate::models::SettingsPersonalComputeMessage) -> SettingsPersonalComputeSetting {
        SettingsPersonalComputeSetting {
            etag: None,
            personal_compute: Box::new(personal_compute),
            setting_name: None,
        }
    }
}


