use schemars::JsonSchema;
/*
 * Databricks Accounts and Workspace REST API on ALL
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(JsonSchema, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CatalogCreateFunction {
    /// A map of key-value properties attached to the securable.
    #[serde(rename = "properties", default, skip_serializing_if = "Option::is_none")]
    pub properties: Option<::std::collections::HashMap<String, String>>,
    /// Function parameter style. **S** is the value for SQL.
    #[serde(rename = "parameter_style")]
    pub parameter_style: ParameterStyle,
    /// Function SQL data access.
    #[serde(rename = "sql_data_access")]
    pub sql_data_access: SqlDataAccess,
    /// Name of parent catalog.
    #[serde(rename = "catalog_name")]
    pub catalog_name: String,
    /// Scalar function return data type.
    #[serde(rename = "data_type")]
    pub data_type: crate::models::CatalogColumnTypeName,
    /// Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the __external_language__ field,  and the __return_params__ of the function cannot be used (as **TABLE** return type is not supported), and the __sql_data_access__ field must be **NO_SQL**. 
    #[serde(rename = "routine_body")]
    pub routine_body: RoutineBody,
    /// Function null call.
    #[serde(rename = "is_null_call")]
    pub is_null_call: bool,
    /// List of schemes whose objects can be referenced without qualification.
    #[serde(rename = "sql_path", skip_serializing_if = "Option::is_none")]
    pub sql_path: Option<String>,
    /// Specific name of the function; Reserved for future use.
    #[serde(rename = "specific_name")]
    pub specific_name: String,
    #[serde(rename = "routine_dependencies")]
    pub routine_dependencies: Vec<crate::models::CatalogDependency>,
    #[serde(rename = "input_params")]
    pub input_params: Vec<crate::models::CatalogFunctionParameterInfo>,
    /// Name of parent schema relative to its parent catalog.
    #[serde(rename = "schema_name")]
    pub schema_name: String,
    /// Function security type.
    #[serde(rename = "security_type")]
    pub security_type: SecurityType,
    /// External function name.
    #[serde(rename = "external_name", skip_serializing_if = "Option::is_none")]
    pub external_name: Option<String>,
    /// Name of function, relative to parent schema.
    #[serde(rename = "name")]
    pub name: String,
    /// Pretty printed function data type.
    #[serde(rename = "full_data_type")]
    pub full_data_type: String,
    /// Whether the function is deterministic.
    #[serde(rename = "is_deterministic")]
    pub is_deterministic: bool,
    /// Function body.
    #[serde(rename = "routine_definition")]
    pub routine_definition: String,
    #[serde(rename = "return_params")]
    pub return_params: Vec<crate::models::CatalogFunctionParameterInfo>,
    /// User-provided free-form text description.
    #[serde(rename = "comment", skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// External function language.
    #[serde(rename = "external_language", skip_serializing_if = "Option::is_none")]
    pub external_language: Option<String>,
}

impl CatalogCreateFunction {
    pub fn new(parameter_style: ParameterStyle, sql_data_access: SqlDataAccess, catalog_name: String, data_type: crate::models::CatalogColumnTypeName, routine_body: RoutineBody, is_null_call: bool, specific_name: String, routine_dependencies: Vec<crate::models::CatalogDependency>, input_params: Vec<crate::models::CatalogFunctionParameterInfo>, schema_name: String, security_type: SecurityType, name: String, full_data_type: String, is_deterministic: bool, routine_definition: String, return_params: Vec<crate::models::CatalogFunctionParameterInfo>) -> CatalogCreateFunction {
        CatalogCreateFunction {
            properties: None,
            parameter_style,
            sql_data_access,
            catalog_name,
            data_type,
            routine_body,
            is_null_call,
            sql_path: None,
            specific_name,
            routine_dependencies,
            input_params,
            schema_name,
            security_type,
            external_name: None,
            name,
            full_data_type,
            is_deterministic,
            routine_definition,
            return_params,
            comment: None,
            external_language: None,
        }
    }
}

/// Function parameter style. **S** is the value for SQL.
#[derive(JsonSchema, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ParameterStyle {
    #[serde(rename = "S")]
    S,
}

impl Default for ParameterStyle {
    fn default() -> ParameterStyle {
        Self::S
    }
}
/// Function SQL data access.
#[derive(JsonSchema, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SqlDataAccess {
    #[serde(rename = "CONTAINS_SQL")]
    ContainsSql,
    #[serde(rename = "READS_SQL_DATA")]
    ReadsSqlData,
    #[serde(rename = "NO_SQL")]
    NoSql,
}

impl Default for SqlDataAccess {
    fn default() -> SqlDataAccess {
        Self::ContainsSql
    }
}
/// Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the __external_language__ field,  and the __return_params__ of the function cannot be used (as **TABLE** return type is not supported), and the __sql_data_access__ field must be **NO_SQL**. 
#[derive(JsonSchema, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RoutineBody {
    #[serde(rename = "SQL")]
    Sql,
    #[serde(rename = "EXTERNAL")]
    External,
}

impl Default for RoutineBody {
    fn default() -> RoutineBody {
        Self::Sql
    }
}
/// Function security type.
#[derive(JsonSchema, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SecurityType {
    #[serde(rename = "DEFINER")]
    Definer,
}

impl Default for SecurityType {
    fn default() -> SecurityType {
        Self::Definer
    }
}

