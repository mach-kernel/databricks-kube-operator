use schemars::JsonSchema;
/*
 * Databricks Accounts and Workspace REST API on ALL
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(JsonSchema, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SqlEndpointInfo {
    /// The amount of time in minutes that a SQL warehouse must be idle (Ie., no RUNNING queries) before it is automatically stopped.  Supported values:   - Must be == 0 or >= 10 mins   - 0 indicates no autostop.  Defaults to 120 mins
    #[serde(rename = "auto_stop_mins", skip_serializing_if = "Option::is_none")]
    pub auto_stop_mins: Option<i32>,
    /// Warehouse type: `PRO` or `CLASSIC`. If you want to use serverless compute, you must set to `PRO` and also set the field `enable_serverless_compute` to `true`.
    #[serde(rename = "warehouse_type", skip_serializing_if = "Option::is_none")]
    pub warehouse_type: Option<WarehouseType>,
    /// the jdbc connection string for this warehouse
    #[serde(rename = "jdbc_url", skip_serializing_if = "Option::is_none")]
    pub jdbc_url: Option<String>,
    /// Optional health status. Assume the warehouse is healthy if this field is not set.
    #[serde(rename = "health", skip_serializing_if = "Option::is_none")]
    pub health: Option<Box<crate::models::SqlEndpointHealth>>,
    /// ODBC parameters for the SQL warehouse
    #[serde(rename = "odbc_params", skip_serializing_if = "Option::is_none")]
    pub odbc_params: Option<Box<crate::models::SqlOdbcParams>>,
    /// Deprecated. Instance profile used to pass IAM role to the cluster
    #[serde(rename = "instance_profile_arn", skip_serializing_if = "Option::is_none")]
    pub instance_profile_arn: Option<String>,
    /// A set of key-value pairs that will be tagged on all resources (Eg., AWS instances and EBS volumes) associated with this SQL warehouse.  Supported values:   - Number of tags < 45.
    #[serde(rename = "tags", skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<crate::models::SqlEndpointTags>>,
    /// unique identifier for warehouse
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Minimum number of available clusters that will be maintained for this SQL warehouse. Increasing this will ensure that a larger number of clusters are always running and therefore may reduce the cold start time for new queries. This is similar to reserved vs. revocable cores in a resource manager.  Supported values:   - Must be > 0   - Must be <= min(max_num_clusters, 30)  Defaults to 1
    #[serde(rename = "min_num_clusters", skip_serializing_if = "Option::is_none")]
    pub min_num_clusters: Option<i32>,
    /// Configures whether the warehouse should use serverless compute
    #[serde(rename = "enable_serverless_compute", skip_serializing_if = "Option::is_none")]
    pub enable_serverless_compute: Option<bool>,
    /// Maximum number of clusters that the autoscaler will create to handle concurrent queries.  Supported values:   - Must be >= min_num_clusters   - Must be <= 30.  Defaults to min_clusters if unset.
    #[serde(rename = "max_num_clusters", skip_serializing_if = "Option::is_none")]
    pub max_num_clusters: Option<i32>,
    /// Logical name for the cluster.  Supported values:   - Must be unique within an org.   - Must be less than 100 characters.
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Configures whether the warehouse should use Photon optimized clusters.  Defaults to false.
    #[serde(rename = "enable_photon", skip_serializing_if = "Option::is_none")]
    pub enable_photon: Option<bool>,
    /// warehouse creator name
    #[serde(rename = "creator_name", skip_serializing_if = "Option::is_none")]
    pub creator_name: Option<String>,
    /// current number of clusters running for the service
    #[serde(rename = "num_clusters", skip_serializing_if = "Option::is_none")]
    pub num_clusters: Option<i32>,
    /// Size of the clusters allocated for this warehouse. Increasing the size of a spark cluster allows you to run larger queries on it. If you want to increase the number of concurrent queries, please tune max_num_clusters.  Supported values: - 2X-Small - X-Small - Small - Medium - Large - X-Large - 2X-Large - 3X-Large - 4X-Large
    #[serde(rename = "cluster_size", skip_serializing_if = "Option::is_none")]
    pub cluster_size: Option<String>,
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<crate::models::SqlState>,
    /// Channel Details
    #[serde(rename = "channel", skip_serializing_if = "Option::is_none")]
    pub channel: Option<Box<crate::models::SqlChannel>>,
    #[serde(rename = "spot_instance_policy", skip_serializing_if = "Option::is_none")]
    pub spot_instance_policy: Option<crate::models::SqlSpotInstancePolicy>,
    /// current number of active sessions for the warehouse
    #[serde(rename = "num_active_sessions", skip_serializing_if = "Option::is_none")]
    pub num_active_sessions: Option<i64>,
}

impl SqlEndpointInfo {
    pub fn new() -> SqlEndpointInfo {
        SqlEndpointInfo {
            auto_stop_mins: None,
            warehouse_type: None,
            jdbc_url: None,
            health: None,
            odbc_params: None,
            instance_profile_arn: None,
            tags: None,
            id: None,
            min_num_clusters: None,
            enable_serverless_compute: None,
            max_num_clusters: None,
            name: None,
            enable_photon: None,
            creator_name: None,
            num_clusters: None,
            cluster_size: None,
            state: None,
            channel: None,
            spot_instance_policy: None,
            num_active_sessions: None,
        }
    }
}

/// Warehouse type: `PRO` or `CLASSIC`. If you want to use serverless compute, you must set to `PRO` and also set the field `enable_serverless_compute` to `true`.
#[derive(JsonSchema, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum WarehouseType {
    #[serde(rename = "TYPE_UNSPECIFIED")]
    TypeUnspecified,
    #[serde(rename = "CLASSIC")]
    Classic,
    #[serde(rename = "PRO")]
    Pro,
}

impl Default for WarehouseType {
    fn default() -> WarehouseType {
        Self::TypeUnspecified
    }
}

