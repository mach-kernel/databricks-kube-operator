/*
 * Databricks Accounts and Workspace REST API on ALL
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`librariesall_cluster_library_statuses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LibrariesallClusterLibraryStatusesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`librariescluster_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LibrariesclusterStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`librariesinstall`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LibrariesinstallError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`librariesuninstall`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LibrariesuninstallError {
    UnknownValue(serde_json::Value),
}


/// Get the status of all libraries on all clusters. A status will be available for all libraries installed on this cluster  via the API or the libraries UI as well as libraries set to be installed on all clusters via the libraries UI. 
pub async fn librariesall_cluster_library_statuses(configuration: &configuration::Configuration, ) -> Result<crate::models::ComputeListAllClusterLibraryStatusesResponse, Error<LibrariesallClusterLibraryStatusesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/2.0/libraries/all-cluster-statuses", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LibrariesallClusterLibraryStatusesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the status of libraries on a cluster. A status will be available for all libraries installed on this cluster via the API  or the libraries UI as well as libraries set to be installed on all clusters via the libraries UI.  The order of returned libraries will be as follows.  1. Libraries set to be installed on this cluster will be returned first.    Within this group, the final order will be order in which the libraries were added to the cluster.  2. Libraries set to be installed on all clusters are returned next.    Within this group there is no order guarantee.  3. Libraries that were previously requested on this cluster or on all clusters, but now marked for removal.    Within this group there is no order guarantee. 
pub async fn librariescluster_status(configuration: &configuration::Configuration, cluster_id: &str) -> Result<crate::models::ComputeClusterLibraryStatuses, Error<LibrariesclusterStatusError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/2.0/libraries/cluster-status", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("cluster_id", &cluster_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LibrariesclusterStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add libraries to be installed on a cluster.  The installation is asynchronous; it happens in the background after the completion of this request.   **Note**: The actual set of libraries to be installed on a cluster is the union of the libraries specified via this method and  the libraries set to be installed on all clusters via the libraries UI. 
pub async fn librariesinstall(configuration: &configuration::Configuration, compute_install_libraries: Option<crate::models::ComputeInstallLibraries>) -> Result<serde_json::Value, Error<LibrariesinstallError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/2.0/libraries/install", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&compute_install_libraries);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LibrariesinstallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set libraries to be uninstalled on a cluster. The libraries won't be uninstalled until the cluster is restarted.  Uninstalling libraries that are not installed on the cluster will have no impact but is not an error. 
pub async fn librariesuninstall(configuration: &configuration::Configuration, compute_uninstall_libraries: Option<crate::models::ComputeUninstallLibraries>) -> Result<serde_json::Value, Error<LibrariesuninstallError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/2.0/libraries/uninstall", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&compute_uninstall_libraries);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LibrariesuninstallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

